<template><div><p><img src="@source/docs/Nextjs/2024-04-05-SomeFirstThoughtsonNext13/img/SomeFirstThoughtsonNext13_0.png" alt="이미지"></p>
<p>몇 달 전에 Next 13에 대해 듣기 시작했을 때 너무 흥분했어요. 시간이 있어서 예시 프로젝트를 만들어 보려고 했어요. 저를 너무 흥분시킨 큰 이유는 새로운 스트리밍 HTML 기능이었어요. 몇 달 전에 읽었을 때 이미 기대가 되었는데, 이 기능이 Next JS와 React에 도입된 걸 보니 더욱 흥미로웠어요. 정말 Next 13을 좋아하고 싶었어요.</p>
<h1 id="사전-릴리스-소프트웨어" tabindex="-1"><a class="header-anchor" href="#사전-릴리스-소프트웨어" aria-hidden="true">#</a> 사전 릴리스 소프트웨어</h1>
<p>경력을 시작할 때 개발자를 위한 소프트웨어는 대부분 유료였어요. 베타 프로그램은 대부분 커뮤니티의 중요 멤버들에게만 제한되어 있었어요.</p>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<p>한편, 이는 새 버전이 출시되었을 때 많은 개발자들이 새로운 기능을 제대로 파악하지 못했다는 것을 의미했습니다. 다른 한편으로, 소수의 베타 테스터들은 새로운 버전을 완전히 활용할 수 있도록 테스터들을 도와줌으로써 새 버전을 개발하는 팀이 도움을 줄 수 있었습니다.</p>
<p>테스터들이 커뮤니티의 중요한 구성원이 되는 방법은 다른 사람들이 소프트웨어를 배우는 데 많은 시간을 투자하여 도와주는 것이었기 때문에, 새 버전을 사용하는 법을 가르치는 데 투자한 시간은 잘 쓴 시간이었습니다.</p>
<p>클로즈 베타는 소프트웨어가 개발 중일 때 비칭하는 리뷰를 방지했습니다. 새 버전이 아직 출시될 준비가 되지 않았다는 것이 명백했을 뿐만 아니라, 베타 테스터들도 다음에 초대되기를 확실히 하고 싶어했습니다.</p>
<p>Angular 2는 오픈 베타 버전에서 소프트웨어를 다루는 첫 경험이었습니다. 일자리를 잃은 후, 다음 일자리를 찾는 동안 학습해야 할 기술로 Angular를 선택했습니다. 문서가 총잡한 것과 이해하기 어려운 것이 힘들었고, 예제들이 지나치게 단순하여 어떻게 더 복잡한 앱을 만들지 추론하기 어려웠습니다. AngularJS보다 더 오랜 시간이 걸렸으며, 누군가가 지불하지 않는 한 제가 만든 것에는 아무도 관심을 보이지 않았습니다.</p>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<p>마지막으로, 다른 AngularJS 프로젝트로 고용되었고, 그 회사에서 React로 전환하는 데에 대한 보상을 받았습니다. 그때부터 Angular는 한 번도 다뤄본 적이 없네요. Angular과 씨름하기 대신 강제 휴가를 즐기면서도 똑같은 결과를 얻었을 거예요.</p>
<p>그래서 새로운 기술이 출시되자마자 곧바로 뛰어들지 않는 편입니다. 그건 대부분 취약점에 부딪히는 데 시간을 낭비하는 것을 기다려서 그들이 써놓은 글들을 읽고 제가 시간을 적게 낭비하려는 이유입니다. 그러나 이번에는 시간이 남아있었고 (그리고 Next 13에 진심이 있었기 때문에) 이전에 활용했던 많은 사람들의 낭비된 시간에 보답하기로 결심했습니다.</p>
<p>발견한 점은 다음과 같습니다.</p>
<h1 id="기대치-설정" tabindex="-1"><a class="header-anchor" href="#기대치-설정" aria-hidden="true">#</a> 기대치 설정</h1>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<p>넥스트 JS 문서에는 넥스트에 대해 다음과 같이 설명되어 있습니다:</p>
<p>최근에 넥스트 JS에 대해 많이 읽어왔는데, 한 게시물에서 &quot;넥스트는 정적 사이트 생성기입니다&quot;라는 내용을 보았습니다. 불행히도 그 블로그 게시물 링크를 찾을 수 없어서, 처음 반응은 &quot;아니야&quot;였습니다. 왜냐하면 Vercel 팀이 얘기한 넥스트의 정체성을 이미 알고 있었기 때문입니다.</p>
<p>실망스럽지만, 그 블로그는 맞았어요. 넥스트는 기본적으로 정적 사이트 생성기입니다. 이는 빌드 시간에 앱의 모든 링크를 크롤링하여 모든 페이지를 만들고 저장하려고 시도합니다. 그것을 끄는 방법이 있더라도 잘 문서화되어 있지 않습니다. 오늘 이 비디오를 우연히 만나서 일부 문제를 요약한 것을 발견했어요:</p>
<p>요약하면, 특정 경로로 이동한 다음 이전 경로로 이동하면, 다시 이동한 경로에서 만든 변경 사항을 반영하지 않습니다 (이 문장이 이해가 안 된다면, 비디오를 보거나 그 행동을 보여주는 첨부된 곳을 보세요). 메인 경로에서 revalidate=0을 설정하거나 하위 경로에서 revalidatePath()를 호출해도 해당 변경 사항이 반영되지 않는다는 문제가 발생합니다.</p>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<p>Next가 &quot;정적 우선&quot; 방식 때문인 것 중 일부입니다. 이에 대한 또 다른 이유는 실제로 두 개의 캐시가 있다는 것입니다: 백엔드 캐시와 프론트엔드/리액트 캐시가 있습니다. 백엔드 캐시는 페이지의 렌더링된 버전을 저장하고, 프론트엔드/리액트 캐시는 방문한 페이지의 상태를 가진 저장된 리액트 컴포넌트를 포함합니다. 뒤로 이동은 항상 &quot;소프트&quot; 이동으로 간주되며, 이전에 방문한 페이지에서 해당 저장된 컴포넌트를 캐시에서 끄집어내거나 새 상태를 제공하는 것과는 상관이 없습니다. 다시 말씀드리겠습니다: 항상 소프트 이동으로 간주되며, 현재 Link 컴포넌트로 강제 이동할 수 있는 방법은 없습니다. 이 프로세스를 설명한 비디오가 있습니다:</p>
<p>Next 팀이 변이가 안정화되지 않았다고 말하는 것이 이것에 해당하는 것 같아요 — 데이터 변경을 나타내는 과정이 현재 매우 고통스럽다는 것 입니다.</p>
<p>하지만 이것이 중요한 부분입니다. 이 정적 사이트 제너레이터로의 기본적인 편향은 더 큰 영향을 미친다는 것을 의미합니다. 이것은 데이터베이스 테이블을 완전히 삭제하고 Next 서버를 중지시킨 다음 레코드가 없는 상태로 다시 테이블을 추가하고 개발 모드를 다시 시작하면 기본적으로 삭제한 테이블에서 유래한 데이터가 여전히 표시된다는 것을 의미합니다. 또는 최소한 이것이 내 프로젝트에서 얼마나 많은 시간을 낭비하며 어떻게 그거릴 멈출 수 있는지 찾아내기 전에 발생했습니다 (몇 버전 전이었습니다). Next는 fetch 호출을 캐시하지 않았지만 fetch 호출 후에 생성된 페이지들을 캐시하고 .next 디렉토리에 저장했다는 점에 있습니다. 서버가 중지되었을 때라도 다시 가동될 때 그 페이지들을 보고 서비스합니다. 기본적으로나 명시된 재검증 기간이 만료된 상태에 관계없이 그렇습니다.</p>
<p>이것만으로 충분히 나쁘지만 그 외에도 여러 가지 영향을 줄 수 있는 사항이 있습니다. 예를 들어, Next가 개발 빌드를 수행할 때 최대한 많은 정적 페이지를 생성하기 위해 데이터베이스에 접근합니다(앱이 데이터베이스를 사용하는 경우 가정).</p>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<p>만약 앱을 테스트하기 위해 컨테이너화 작업 중이고 아직 데이터베이스 컨테이너가 작동하지 않는 상황이라면, 개발 빌드가 실패할 것입니다. 하지만 도커 파일 대부분은 작업 디렉토리의 모든 것을 컨테이너로 복사하기 위한 지시를 가지고 있기 때문에 화면에서 오류 메시지를 볼 수 없을 수도 있고 빌드가 실패했음을 실제로 깨닫지 못할 수도 있습니다. 그리고 .next 디렉토리에는 아마도 로컬로 앱을 dev 모드로 실행했을 때 Next가 마지막으로 빌드한 정적 파일들이 들어 있을 것입니다. 컨테이너 안에서 사이트가 실행되는 것을 보고 있으면, 주의를 기울이지 않으면 화면에서 보이는 레코드가 테스트 데이터베이스에 존재하지 않는다는 것을 깨닫지 못할 수 있습니다. 이것이 빌드가 실패한 이유인데, 사이트가 동작하고 있기 때문에 실패했다는 것을 알 수 없습니다.</p>
<p>또한, 테스트 중이므로 Next의 캐싱 기능을 가능한 한 많이 끄는 것이 좋습니다. 왜냐하면 테스트 실행 사이에 다양한 캐시를 지우는 문서화된 방법이 없기 때문입니다. 따라서 e2e 테스트는 Next로부터 성능 향상을 기대하기 어렵습니다. 새 버전의 핵심은 리액트 서버 컴포넌트이기 때문에 대부분의 앱에 대해 Jest를 사용한 단위 테스트를 진행할 수 없을 것으로 보입니다. 대부분의 테스트를 위해서는 e2e 테스트에 의존해야 할 것입니다.</p>
<p>이 모든 것은 지적하는데 오랜 이야기가 필요한 건데, 만약 이 버전이 최종적으로 작동하는 방식이라면, 문서들은 완전히 정적인 Next 13의 성격에 대해 더욱 솔직해야 한다는 것을 의미합니다. 그러나 뒷단으로 많은 로직을 이동하는 것에 중점을 둔 이 버전이 기본적으로 정적인 이유에 대해 진심한 의문이 듭니다.</p>
<p>제게는 데이터 상호작용이 가능한 사이트이지만 주로 정적 페이지인 사이트가 기본적인 것이 아니라, 전체 세계에서 고대하는 것은 에지 케이스로 보입니다. 워드프레스가 있는데요. 만약 이를 고대하는 수요층이 있다면, Vercel은 이를 직접적으로 더 많이 홍보하고, 이 도구가 우리에게 맞지 않을 수도 있다는 것을 분명하게 해야 합니다. 또는 최소한, 더 일반적인 앱에 사용하는 방법을 알려주어야 합니다.</p>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<h1 id="인터셉팅-라우트-미로-속-토끼-구멍" tabindex="-1"><a class="header-anchor" href="#인터셉팅-라우트-미로-속-토끼-구멍" aria-hidden="true">#</a> 인터셉팅 라우트 미로 속 토끼 구멍</h1>
<p><img src="@source/docs/Nextjs/2024-04-05-SomeFirstThoughtsonNext13/img/SomeFirstThoughtsonNext13_1.png" alt="이미지"></p>
<p>나는 모달을 표시하고 해제하기 위해 인터셉팅 라우트를 사용하려고 시작했습니다. 문서가 지금보다 더 혼란스러웠는지, 아니면 너무 많은 것을 기억하려고하다 보니 이해하지 못했는지 확신할 수 없지만, 인터셉팅 라우트가 특수한 경우를 위한 것이고 일반 병렬 라우트를 사용하여 모달을 열고 닫을 수 있다는 것을 이해하지 못했습니다. 모달을 열거나 닫을 때 동작이 달라야 하는 경우가 아닌 한 특별한 동작이 필요하지 않은 경우라면 인터셉팅 라우트를 사용할 필요가 없다는 것을 알게 되었습니다.</p>
<p>나는 처음에 원하는 행동을 보여주는 예시 저장소를 찾지 못해서 더욱 답답해했습니다. 결국, 인터셉팅 라우트 문서 맨 끝에 짧은 링크를 발견했고, 이 링크는 한 개의 인터셉팅 라우트를 보여주는 저장소로 이동했지만, 더 많은 인터셉팅 라우트가 있는 경우나 다른 깊이에 인터셉팅 라우트가 있는 경우에는 어떻게 해결해야 하는지에 대한 질문에 대한 해답을 제시하지 않았습니다.</p>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<p>제가 원하는 결과물에 도달하기 위해 어떤 디렉토리 구조를 사용해야 할지 알아내는 데 많은 어려움을 겪었어요 (특히 예시 레포를 찾기 전까지). 그래서 라우팅을 가로채는 필요가 없다는 것을 깨달을 때 정말 안도했어요. 하지만 아직 문서에 이 부분이 어떻게 작동해야 하는지에 대한 많은 질문이 남아 있는 것 같아요.</p>
<h1 id="이-일을-왜-하나요" tabindex="-1"><a class="header-anchor" href="#이-일을-왜-하나요" aria-hidden="true">#</a> 이 일을 왜 하나요?</h1>
<p>또 다른 관련 문제는 대화 상자 요소(dialog element)를 모달로 사용하고 싶었던 점입니다 (그게 그 용도니까요). 그러나 대화 상자에 문제가 있어서 JavaScript를 사용하지 않으면 모달로 대화 상자를 열 수 없다는 것이었죠. 이게 문제인 이유는 이제 어떤 모달도 클라이언트 컴포넌트여야 한다는 것입니다. 그리고 제 모달 중 일부에는 시각적으로 동일한 양식이 들어있는데, 하나는 추가이고 다른 하나는 업데이트인 경우가 있었어요. 보통 상황에서라면 제출할 때 사용할 콜백을 주입하고 동일한 모달/양식을 재사용할 수 있어요. 그러나 Functions can't be serialized 때문에 React 컴포넌트로 서버 액션을 전달할 수 없고, 양식이 JavaScript가 필요한 모달 안에 있기 때문에 서버 액션을 직접 컴포넌트로 가져와야 하죠. 그렇게 되면 해당 컴포넌트를 다른 양식 액션으로 재사용할 수 없게 됩니다. 우흥.</p>
<p>이것은 서버 컴포넌트의 문제를 가리키는데, 비교적 사소한 것을 위해 showModal을 Dialog 요소에서 호출하는 것과 같이 자주 JavaScript를 사용해야 한다는 점이죠. 이렇게 하면 클라이언트를 사용해야 하는 선택사항으로 나오고, HTML을 스트리밍으로 사용할 수 없게 될 정도로 자주 사용할 수 없기 때문에 그만큼의 성능 이점을 얻지 못하게 됩니다. 그렇기 때문에 명시적으로 Next에서 제공하는 그것을 끄고 남은 시간동안에 문제 해결을 해야 합니다. 이렇게 하면 성능 이점을 얻지 못하고 번거로운 작업을 해야 하는 것이죠.</p>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<p>JavaScript를 UI의 작은 부분에 끼워 넣는 방법으로도 기술적으로는 작동하지만 개념적으로는 잘 맞지 않는데요. 그건 내가 지옥이 얼어붙을 때 해야 할 일 목록에서 상당히 밑에 있는 항목이야.</p>
<h1 id="디버깅-도움-및-문서" tabindex="-1"><a class="header-anchor" href="#디버깅-도움-및-문서" aria-hidden="true">#</a> 디버깅, 도움 및 문서</h1>
<p>현재 Next 13의 큰 문제점 중 하나는 예제 프로젝트의 부족입니다. 문서에서는 Discord 채널에 가입하여 도움을 받으라고 제안하지만, 그 채널은 응답이 없었어요. 우연일 수도 있지만, 내 성별을 숨긴 디스플레이 이름으로 바꾼 후에는 아주 조금 더 나은 답변을 받았어요. 사실, Stack Overflow가 훨씬 더 도움이 되었답니다.</p>
<p>경로를 가로채는 문제에 부딪혔을 때, 어떻게 디버깅해야 할지가 즉시 분명하지 않았어요. 프레임워크를 파일을 올바른 경로에 두고 기반으로 하는 것의 문제는 당신이 그렇게 했다고 생각했는데 작동하지 않을 때, 어떻게 디버깅하거나 그 문제를 해결할지 알 수 없다는 것이에요. 그리고 Discord 채널에 물어봐도 분명히 대답이 될리가 없지요.</p>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<p>또한, 문서에는 앱 라우터를 사용할 때 문서의 앱 라우터 &quot;쪽&quot;에 머무르도록 조심해야 한다는 내용이 나와 있지만, 앱 라우터 쪽에서 디버깅 도움을 중복으로 제공하지는 않았습니다. 도움을 찾아보더라도 Next가 기록을 유지하는 방법이나 더 나은 로깅을 활성화하는 방법에 대한 정보는 전혀 제공하지 않습니다.</p>
<p>팁: 결국 .next 폴더에 어떤 종류의 쓸모없는 로그 파일을 찾을 수 있었습니다.</p>
<h1 id="무작위-이상한-일들" tabindex="-1"><a class="header-anchor" href="#무작위-이상한-일들" aria-hidden="true">#</a> 무작위 이상한 일들</h1>
<p><img src="@source/docs/Nextjs/2024-04-05-SomeFirstThoughtsonNext13/img/SomeFirstThoughtsonNext13_2.png" alt="이미지"></p>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<p>나는 정말 이상한 일들도 겪었어요. 아마도 이건 미리 릴리스된 소프트웨어이기 때문이라고 생각해요. 예를 들어, 루트 매개변수로 10을 엔드포인트에 보낼 때, 1로 변환되었어요. 이 문제를 해결하기 위해 전체 컬렉션을 가져오는 작업 엔드포인트를 사용해서 id가 10인 아이템을 얻었어요. 이것은 분명히 프로덕션 시스템에서 사용하기에는 적합하지 않아요.</p>
<p>내 앱은 프로덕션 빌드를 하지 않지만, 자녀 레코드를 생성하는 화면으로 이동하려고 하면 문제가 발생해요. 이것은 어떻게 보면 Next 번들링 문제 같지만, Next 팀이 버그로 지연되어 아직 이를 살펴보지 않은 것 같아요. 이 문제를 해결하려고 노력할지, 아니면 다음 직장을 시작하기 전에 집에서 해야 할 일을 먼저 처리할지 결정 중이에요. 아마도 거기서는 Next 13이 필요하지 않겠죠 🤷‍♀️.</p>
<p>업데이트: Vercel이 이 버그를 해결했고, 내 작업을 <code v-pre>use server</code>로 표시하지 않았기 때문에 생긴 이 알 수 없는 오류를 가리켰어요. 이것은 이러한 것들을 잘못하고 어떻게 무엇이 발생했는지 알아내는 방법에 대한 정보가 얼마나 제한적인지를 나타냅니다.</p>
<p>또한, 서버 구성 요소에서 URL 검색 매개변수(쿼리 문자열)를 가져올 수 없다는 이상한 문서화되지 않은 제한이 있어요. 이는 그들의 유용성을 더욱 제한한다는 점입니다.</p>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<h1 id="마지막으로" tabindex="-1"><a class="header-anchor" href="#마지막으로" aria-hidden="true">#</a> 마지막으로</h1>
<p><img src="@source/docs/Nextjs/2024-04-05-SomeFirstThoughtsonNext13/img/SomeFirstThoughtsonNext13_3.png" alt="이미지"></p>
<p>이 새 소프트웨어에 대한 환상적인 리뷰를 작성할 수 있었으면 좋겠어요. 안타깝게도, 그렇게 할 수가 없네요. 새 Next 버전의 정적 우선 모델이 React Server 컴포넌트의 도입과 근본적으로 충돌하고 있다는 느낌을 받습니다. 현재 이 충돌로 인해 발생하는 제한 사항과 예상치 못한 동작은 실제로 Next에서 약속한 성능을 뽑아내는 데 막대한 노력이 필요할 것으로 보입니다.</p>
<p>이번 소프트웨어 버전에는 정말 멋진 기능들이 많지만, 실제 프로젝트에서 빠른 마감 기한을 가진 상황에서 Next에서 기본적인 작업을 하는 데 필요한 추가 시간을 허용할 수 있는 상상조차 할 수 없네요.</p>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<p>첫 번째로 React Server Components를 지원하는 첫 번째 프레임워크이기 때문에, 다른 프레임워크가 그 지원을 추가하지 않기로 결정할 수도 있다거나 관련하여 불합리하게 비난받을 수도 있다는 걱정이 있어요. 사실 Next 외에 RSC로 인해 확실히 아는 제한은 함수를 클라이언트 구성 요소로 전달할 수 없는 방식이고, 이는 Forms의 재사용을 방해한다는 것 뿐입니다. 함수를 직렬화하는 것은 가능하지 않았기 때문에 RSC에 그것을 돌릴 수 없다는 것을 우리는 정말 그들에게 돌릴 수 없습니다.</p>
<p>만약 Next 13이 공개되었다가 몇 달 동안 사용 가능했더라면 이 모든 문제에 덜 걱정할 것입니다. 그러나 Next 13 튜토리얼은 6개월이 넘는 구 업로드도 있는데요. 기업이 설계에 많은 자원을 투입했을 때 사용자 의견에 대처하여 완전히 다른 디자인으로 방향을 전환하는 것은 드물어요. 특히 그 디자인이 수개월 동안 공개되었는데 사용자 의견에 맞게 변했다는 것은 더욱 그러해요.</p>
<p>내 의견으로는, Next 13의 혜택을 정말로 받을 수 있는 경우는 매우 드물하고, 모든 다양한 부분 사이에 혼란이 많이 있습니다. 이 모든 게 사실일 때, 종종 최고의 해결책은 디자인을 처음부터 다시 검토하는 것이라고 생각합니다. 그리고 나는 지금 이 시점에서 그런 일이 일어날 확률이 적다고 느꼈습니다.</p>
<p>하지만 아마도 너무 걱정하고 있는 것일지 모르겠고, 아마 괜찮을 거예요.</p>
<!-- ui-log 수평형 -->
<p><ins class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-4877378276818686"
  data-ad-slot="9743150776"
  data-ad-format="auto"
  data-full-width-responsive="true"></ins></p>
<component is="script">
(adsbygoogle = window.adsbygoogle || []).push({});
</component>
<p>알림: 최소 1주일 동안 무료로 제공하고, 이후에는 유료로 전환할 계획입니다.</p>
</div></template>
